---
title: An Essay On Technical Sophistication
layout: post
tags: [software, programming, technical-sophistication, learning]
---


## Building Technical Sophistication As A Developer

![thinking](https://sudipbhandari126.github.io/resources/thinking.png "thinking")

Idea and concept wise it's something we all developers are quite aware of. I first came through this exact term, "technical sophistication" in Michael Hartl's article in [Learn Enough Society](https://www.learnenough.com/). The basic idea is as developer one requires a certain set of skills which can elevate their overall vision and can see things in a broad sight. One need not be technically proficient at everything but having good understanding of fundamentals enables us to debug and reach the solution faster. Just by digging through error logs, searching efficiently on google/stack-overflow or open source community (github, slack channels, etc) a developer with enough "
technical sophisticaion" can solve his/her way towards problem in lesser time with higher efficiency.

I didn't start out as a computer-kid. Growing up in rural village of Nepal I wasn't even familiar with the computers. The whole decision to pursue computer science and engineering was not even a very well-informed decision for me. Looking back, I think it was a perfectly fine decision and this field even seems to be in compliance with my personality and mentality or may be I have adapted myself subconsciously. The whole point is, higher the exposure greater the sophistication. You have seen a bit of it here, a bit of it there, similar thing happened when you were doing X, Y does this 'that way' and so on. Over the years what I have realized is there are a lot of things which can be learned only through experience. But a common problem (me included) is there is no enough experience.

I have realized that for later boomers like me the sure fast way to build technical sophistication is to move faster. If you are a core java programmer, as an example, do the following:

- go to github (register if you haven't already)
- take a language/framework/technology that is vaguely related to your domain/preference (Let's take ruby)
- find out an interesting ruby pet project posted by some hobbyist (there are plenty of them for any language) with a good readme for instruction
- go ahead and try to run that project in your system

NB: This is just an example. The basic idea is to try and do something which is fairly unknown. I have found that the end results are always helpful and insightful in the long run.

Now, one thing is sure to happen. It won't be a smooth experience. You will face quite some technical challenges while installing, running the project. You will understand how this particular language that you have never used before manages it's libararies. Hopefully (:bowtie:) you come through a lot of OS related issues too. You thought you downloaded the correct package but oops it was a wrong non-compliant version. You messed up your package structure and might have to uninstall some and install them again in a proper way. In my mind, this is how you build technical sophistication. 

## Freedom in software engineering

Software engineering field is very appropriate for experimentation. The amount of freedom and experimentation that we software engineers enjoy can't be exercised in any other disciplines of engineering. The hottest field in software industry today, machine learning is in itself a glorified experimentation, although there are tons of sophisticated mathematical and logical heuristics behind. How much do we actually leverage on the fact that we can experiment with our code and system with such freedom. If you want to be a sophisticated power user of linux who really understands the system and not just the commands set out on a journey and install arch linux, (do it only on weekends :bowite: ). 

As a programmer I am constantly reminded of how the learning was for first generation of computer programmers. They learned in a hostile environment, so to speak of, where there was a huge constraint on memory and processing capacity, both of which are in abundance today. Software collaboration has never been easier with tools like github and other communities. Free and open source software (FOSS) has kept growing and flourishing and communities around it are very much welcoming towards whoever wants to venture into it.


> This essay is more like a note to myself that I should keep the joy of software engineering alive and explore more.



