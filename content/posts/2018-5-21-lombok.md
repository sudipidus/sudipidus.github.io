---
layout: post
title: Leveraging Lombok Annotations to spice up Java
tags: [java, lombok, annotation, meta-programming]
date: "2018-05-21"
---

Java is heavily criticized and hated for its verbosity. Even for things such as reading/writing files we have to ceremoniously write a lot of generic stuff. The increasingly popular Java library Lombok has been hugely successful in addressing this issue. It's an annotation based Java library that plugs itself into editors, IDE, and build tools at compile time, facilitating the generation of boilerplate code and making the code clean and more readable. There are a lot of features and annotations in this library, but to illustrate how useful I have found it in my day to day work I am going to talk about  @Data  annotation.

Let's say we have a POJO (Plain old Java object) to represent some sort of data in our program. Using vanilla Java this is what we get:

```java
public class Person {
    private String id,name,nationality;

    public Person(String id, String name, String nationality) {
        this.id = id;
        this.name = name;
        this.nationality = nationality;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNationality() {
        return nationality;
    }

    public void setNationality(String nationality) {
        this.nationality = nationality;
    }

//override equals, hashCode,toString
}
```

There is nothing wrong with this code. Much of these boilerplate codes can be generated by using internal IDE tools too. But going through this code is not a pleasant experience. Is it just a Data class or are there some special methods embedded too? Now let's write the same using @Data.
```java
import lombok.Data;

@Data
public class Person {
    private String id,name,nationality;
}
```


Yup, that's it. @Data   annotation creates getters, setters, constructors, overrides equals, hashCode and toString all for us. The code is now very clean and readable, not confusing. For this to work, we need to import Lombok library (jar, Gradle, and Maven) and based on IDE, annotation processing should be turned on. For example, in IntelliJ:

Enable annotation processing

After annotating the Java class, we can check what's been inserted by using the javap  disassembler or IDE tool called Delombok .

For our above example:
```java
//generated using delombok tool of  Intellij IDEA

public class Person {
    private String id,name,nationality;

    public Person() {
    }

    public String getId() {
        return this.id;
    }

    public String getName() {
        return this.name;
    }

    public String getNationality() {
        return this.nationality;
    }

    public void setId(String id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setNationality(String nationality) {
        this.nationality = nationality;
    }

    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Person))
            return false;
        final Person other = (Person) o;
        if (!other.canEqual((Object) this))
            return false;
        final Object this$id = this.getId();
        final Object other$id = other.getId();
        if (this$id == null ? other$id != null : !this$id.equals(other$id))
            return false;
        final Object this$name = this.getName();
        final Object other$name = other.getName();
        if (this$name == null ? other$name != null : !this$name.equals(other$name))
            return false;
        final Object this$nationality = this.getNationality();
        final Object other$nationality = other.getNationality();
        if (this$nationality == null ? other$nationality != null : !this$nationality.equals(other$nationality))
            return false;
        return true;
    }

    public int hashCode() {
        final int PRIME = 59;
        int result = 1;
        final Object $id = this.getId();
        result = result * PRIME + ($id == null ? 43 : $id.hashCode());
        final Object $name = this.getName();
        result = result * PRIME + ($name == null ? 43 : $name.hashCode());
        final Object $nationality = this.getNationality();
        result = result * PRIME + ($nationality == null ? 43 : $nationality.hashCode());
        return result;
    }

    protected boolean canEqual(Object other) {
        return other instanceof Person;
    }

    public String toString() {
        return "Person(id=" + this.getId() + ", name=" + this.getName() + ", nationality=" + this.getNationality() +
                ")";
    }
}
```


This is just one example of how we can use Lombok to spice up our java coding. There are numerous other annotations for purposes like exception handling, resource cleaning and so on. 